<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang style="line-height:1.5; font-family:Georgia, serif; font-size:20px; color:#1a1a1a; background-color:#fdfdfd" bgcolor="#fdfdfd">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title> </title>
  <style>@media (max-width: 600px) {
    body {
        font-size: 0.9em !important;
        padding: 1em !important
        }
    h1 {
        font-size: 1.8em !important
        }
    }
@media print {
    body {
        background-color: transparent !important;
        color: black !important;
        font-size: 12pt !important
        }
    p, h2, h3 {
        orphans: 3 !important;
        widows: 3 !important
        }
    h2, h3, h4 {
        page-break-after: avoid !important
        }
    }</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body style="margin:0 auto; max-width:36em; padding-left:50px; padding-right:50px; padding-top:50px; padding-bottom:50px; hyphens:auto; overflow-wrap:break-word; text-rendering:optimizeLegibility; font-kerning:normal">
<header id="title-block-header" style="margin-bottom:4em; text-align:center" align="center">
<h1 class="title" style="margin-top:1.4em"> </h1>
</header>
<p style="margin:1em 0"><em>Originally created by Jerrett Longworth in Fall 2020.</em></p>
<h1 id="endianness" style="margin-top:1.4em">Endianness</h1>
<p style="margin:1em 0">Suppose you have an integer stored in memory with the value
<code style='font-family:Menlo, Monaco, "Lucida Console", Consolas, monospace; font-size:85%; margin:0; white-space:pre-wrap'>169552957</code>, or <code style='font-family:Menlo, Monaco, "Lucida Console", Consolas, monospace; font-size:85%; margin:0; white-space:pre-wrap'>0x0A1B2C3D</code> in hexadecimal.
Depending on the archetecture of your system, the actual
<em>ordering</em> of these bytes making up this integer can be
different. This difference is the “endianness” of the data in
memory.</p>
<h2 id="big-endian" style="margin-top:1.4em">Big-endian:</h2>
<p style="margin:1em 0">Bytes are stored with the most significant bit
<strong>first</strong>.</p>
<pre style="margin:1em 0; overflow:auto"><code style='font-family:Menlo, Monaco, "Lucida Console", Consolas, monospace; font-size:85%; margin:0; white-space:pre-wrap; padding:0; overflow:visible; overflow-wrap:normal'>0A1B2C3D

+----+----+----+----+
| 0A | 1B | 2C | 3D |
+----+----+----+----+

Memory address increasing ----&gt;</code></pre>
<h2 id="little-endian" style="margin-top:1.4em">Little-endian:</h2>
<p style="margin:1em 0">Bytes are stored with the most significant bit
<strong>last</strong>.</p>
<pre style="margin:1em 0; overflow:auto"><code style='font-family:Menlo, Monaco, "Lucida Console", Consolas, monospace; font-size:85%; margin:0; white-space:pre-wrap; padding:0; overflow:visible; overflow-wrap:normal'>0A1B2C3D

+----+----+----+----+
| 3D | 2C | 1B | 0A |
+----+----+----+----+

Memory address increasing ----&gt;</code></pre>
<h2 id="another-example" style="margin-top:1.4em">Another example:</h2>
<p style="margin:1em 0">Imagine I was storing the number <code style='font-family:Menlo, Monaco, "Lucida Console", Consolas, monospace; font-size:85%; margin:0; white-space:pre-wrap'>5</code> in binary. This could
be different in memory depending on its endianness.</p>
<p style="margin:1em 0"><code style='font-family:Menlo, Monaco, "Lucida Console", Consolas, monospace; font-size:85%; margin:0; white-space:pre-wrap'>5</code> in binary is <code style='font-family:Menlo, Monaco, "Lucida Console", Consolas, monospace; font-size:85%; margin:0; white-space:pre-wrap'>101</code>. In a 32-bit integer, it
would be padded with zeros like this:</p>
<pre style="margin:1em 0; overflow:auto"><code style='font-family:Menlo, Monaco, "Lucida Console", Consolas, monospace; font-size:85%; margin:0; white-space:pre-wrap; padding:0; overflow:visible; overflow-wrap:normal'>00000000 00000000 00000000 00000101</code></pre>
<p style="margin:1em 0">(The spaces are for your readability, but in reality there are no
gaps in a computer’s memory.)</p>
<p style="margin:1em 0">Once represented in memory, it will look like this:</p>
<pre style="margin:1em 0; overflow:auto"><code style='font-family:Menlo, Monaco, "Lucida Console", Consolas, monospace; font-size:85%; margin:0; white-space:pre-wrap; padding:0; overflow:visible; overflow-wrap:normal'>Big-endian:
00000000 00000000 00000000 00000101


Little-endian:
00000101 00000000 00000000 00000000</code></pre>
<p style="margin:1em 0">Notice how the bytes in the little-endian representation are
reversed. They would have the same size and location in memory, but
internally, the bytes are arranged differently.</p>
<p style="margin:1em 0">If there were two integers, side-by-side in memory, little-endian
does not mean that the entire block of memory is reversed. It means that
<em>specific pieces of data</em> within memory are reversed. Look, I
know it’s weird, but I didn’t make this up. Check out this example:</p>
<pre style="margin:1em 0; overflow:auto"><code style='font-family:Menlo, Monaco, "Lucida Console", Consolas, monospace; font-size:85%; margin:0; white-space:pre-wrap; padding:0; overflow:visible; overflow-wrap:normal'>Storing the integer '5' followed by the integer '69' (nice) in memory:

Big-endian:
00000000 00000000 00000000 00000101 00000000 00000000 00000000 01000101
|               '5'               | |               '69'              |

Little-endian:
00000101 00000000 00000000 00000000 01000101 00000000 00000000 00000000
|               '5'               | |               '69'              |</code></pre>
</body>
</html>